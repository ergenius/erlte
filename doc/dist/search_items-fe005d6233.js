searchNodes=[{"doc":"","ref":"erlte.html","title":"erlte","type":"module"},{"doc":"Compile the specified input with no variables and default format specifications","ref":"erlte.html#compile/1","title":"erlte.compile/1","type":"function"},{"doc":"Compile the specified input with variables and default format specifications","ref":"erlte.html#compile/2","title":"erlte.compile/2","type":"function"},{"doc":"Compile the specified input according to the format specification","ref":"erlte.html#compile/3","title":"erlte.compile/3","type":"function"},{"doc":"Read the compiled template from the specified file","ref":"erlte.html#compiled_read_file/1","title":"erlte.compiled_read_file/1","type":"function"},{"doc":"Write the compiled template to the specified file","ref":"erlte.html#compiled_write_file/2","title":"erlte.compiled_write_file/2","type":"function"},{"doc":"Render the compiled template without replacing any variables There is no error return case now but some maybe added in the future so for compatibility you should handle a generic error case too.","ref":"erlte.html#render/1","title":"erlte.render/1","type":"function"},{"doc":"Render compiled template replacing the specified variables There is no error return case now but some maybe added in the future so for compatibility you should handle a generic error case too.","ref":"erlte.html#render/2","title":"erlte.render/2","type":"function"},{"doc":"Render the compiled template replacing the specified variables and return a new compiled template There is no error return case now but some maybe added in the future so for compatibility reasons you should handle a generic error case too.","ref":"erlte.html#render_to_compiled/2","title":"erlte.render_to_compiled/2","type":"function"},{"doc":"Render compiled template and save the result into the specified file","ref":"erlte.html#render_to_file/2","title":"erlte.render_to_file/2","type":"function"},{"doc":"Render compiled template replacing the specified variables and save the result into the specified file","ref":"erlte.html#render_to_file/3","title":"erlte.render_to_file/3","type":"function"},{"doc":"","ref":"erlte.html#t:compiled/0","title":"erlte.compiled/0","type":"type"},{"doc":"","ref":"erlte.html#t:format_specs/0","title":"erlte.format_specs/0","type":"type"},{"doc":"","ref":"erlte.html#t:node_specs/0","title":"erlte.node_specs/0","type":"type"},{"doc":"","ref":"erlte.html#t:tags_specs/0","title":"erlte.tags_specs/0","type":"type"},{"doc":"","ref":"erlte.html#t:trim_specs/0","title":"erlte.trim_specs/0","type":"type"},{"doc":"","ref":"erlte_compiler.html","title":"erlte_compiler","type":"module"},{"doc":"Compile the specified input according to the format specification","ref":"erlte_compiler.html#compile/3","title":"erlte_compiler.compile/3","type":"function"},{"doc":"","ref":"erlte_renderer.html","title":"erlte_renderer","type":"module"},{"doc":"Render the compiled template replacing the specified variables There is no error return case now but some maybe added in the future so for compatibility reasons you should handle a generic error case too.","ref":"erlte_renderer.html#render/2","title":"erlte_renderer.render/2","type":"function"},{"doc":"Render the compiled template replacing the specified variables and return a new compiled template There is no error return case now but some maybe added in the future so for compatibility reasons you should handle a generic error case too.","ref":"erlte_renderer.html#render_to_compiled/2","title":"erlte_renderer.render_to_compiled/2","type":"function"},{"doc":"Render compiled template to the specified file","ref":"erlte_renderer.html#render_to_file/2","title":"erlte_renderer.render_to_file/2","type":"function"},{"doc":"Render compiled template replacing the specified variables and save the result into the specified file","ref":"erlte_renderer.html#render_to_file/3","title":"erlte_renderer.render_to_file/3","type":"function"},{"doc":"","ref":"erlte_utils.html","title":"erlte_utils","type":"module"},{"doc":"Simple version of html entities encode","ref":"erlte_utils.html#html_entities_encode/1","title":"erlte_utils.html_entities_encode/1","type":"function"},{"doc":"Remove a list from the begining of another list. If the list is not found false is returned. If the is found the remaining of the second list is returned.","ref":"erlte_utils.html#list_remove_start_list/2","title":"erlte_utils.list_remove_start_list/2","type":"function"},{"doc":"Convert variable name to binary","ref":"erlte_utils.html#variable_name_to_binary/1","title":"erlte_utils.variable_name_to_binary/1","type":"function"},{"doc":"Fast Erlang template library with bundling support for HTML, JavaScript and CSS files.","ref":"readme.html","title":"Overview","type":"extras"},{"doc":"The need for erlte arose while using good old sgte in various web applications. I was quite happy with the simplicity of sgte for many years, but concerned about the rendering speed. When I finally replaced sgte with my new shiny library, I could see around 5x times faster rendering speed!","ref":"readme.html#motivation","title":"Overview - Motivation","type":"extras"},{"doc":"Fast rendering. Simple. Reading this file should be enough for understanding most use case scenarios. Supports replacing blocks of delimited code with your own values both at compilation or rendering time (variables). Supports escaping HTML variables. I wouldn't call that 'secure', but it's better than nothing. Supports bundling HTML files using custom HTML elements. Supports bundling JavaScript files using native JavaScript side effect static import declarations. Supports bundling CSS files using CSS @import rules for strings. Supports writing and reading compiled templates. Templates default variables delimiters are friendly with most HTML, CSS or JavaScript editors and browsers. Can also be used with strings or binaries instead of files.","ref":"readme.html#features","title":"Overview - Features","type":"extras"},{"doc":"Only JavaScript static import declarations are supported. CSS @import rules work fine only with file strings (no list of media queries or url are supported). erlte &quot;compiler&quot; is far away from a full HTML/JS/CSS parser. It behaves well for most scenarios, but some corner cases may exist. As long as you use single line imports and you don't nest unescaped comments or imports in strings, you should be fine. erlte does not support any conditionals or pseudocode and will probably never do. For some, this is a limitation, for me, it's a feature. The price of implementing this will be a much slower rendering speed. I also don't like polluting my HTML templates with spaghetti code. We have JavaScript for that.","ref":"readme.html#limitations","title":"Overview - Limitations","type":"extras"},{"doc":"sgte - a simple Erlang Template Engine https://github.com/filippo/sgte","ref":"readme.html#alternatives","title":"Overview - Alternatives","type":"extras"},{"doc":"Github pages: https://ergenius.github.io/erlte/ '/doc' subdirectory (generated by ex_doc)","ref":"readme.html#documentation","title":"Overview - Documentation","type":"extras"},{"doc":"Compile your template. Avoid compiling the template for each rendering! Cache the compilation result for later usage. Helpers for saving compiled templates to files are provided. Render the compiled template.","ref":"readme.html#recommended-flow","title":"Overview - Recommended flow","type":"extras"},{"doc":"Erlang examples Compile and render a file template: { ok , Compiled } = erlte : compile ( { file , &quot;/path/to/template/file.html&quot; } ) , Variables = [ { language , &quot;Erlang&quot; } , { designed_by , &quot;Joe Armstrong, Robert Virding and Mike Williams&quot; } ] , { ok , Rendered } = erlte : render ( Compiled , Variables ) . Compile and render a list: { ok , Compiled } = erlte : compile ( &quot;{{project}} was designed by {{author}}&quot; ) , Variables = [ { project , &quot;erlte&quot; } , { author , &quot;Madalin&quot; } ] , { ok , Rendered } = erlte : render ( Compiled , Variables ) . Compile a binary: { ok , Compiled } = erlte : compile ( &lt;&lt; &quot;{{project}} was designed by {{author}}&quot; &gt;&gt; ) , You are free to mix ANY atoms, lists, binaries or integer numbers for variable names: { ok , Compiled } = erlte : compile ( &quot;{{molecule}} {{server is down}} {{1}}&quot; ) , Variables = [ { molecule , &quot;atoms are OK&quot; } , { &lt;&lt; &quot;server is down&quot; &gt;&gt; , &quot;binaries are OK&quot; } , { 1 , &quot;integers are OK&quot; } ] , { ok , Rendered } = erlte : render ( Compiled , Variables ) . You can also specify a function that returns the value to be rendered instead of the variable value. The function must be exported from the specified module and must have arity = 4. The function will receive the template file format, the variable name, variable value, argument as parameters and must return a binary. Argument is atom undefined in the example below but can be any Erlang term(). % Define the function somewhere in a module (remember to export the function). % If anything goes wrong with your function including if your function does not return a binary, an exception will be trown! - export ( [ your_function / 4 ] ) . your_function ( TemplateFormat , VariableName , VariableValue , Arg ) -&gt; &lt;&lt; &quot;do_some_magic_here&quot; &gt;&gt; . % Later you can use this function to render any variable you want Variables = [ { variable_name , { VariableValue , { f , your_module_name , your_function , undefined } } } ] . Save the compiled template to a file ('erlte' extension is recommended): { ok , Compiled } = erlte : compile ( &quot;{{language}} was designed by {{designed_by}}&quot; ) , ok = erlte : compiled_write_file ( &quot;/path/to/template/compiled.erlte&quot; , Compiled ) . Read a compiled template from a file and render it: &gt; { ok , Compiled } = erlte :compiled_read_file ( &quot;/path/to/template/compiled.erlte&quot; ) . &gt; { ok , Rendered } = erlte :render ( Compiled ) . Templates examples Let's have a quick look at some examples. You can find more templates samples into examples/templates project directory. HTML demonstrating erlte-import custom HTML element &lt;erlte-import&gt;./fragments/html-begin.html&lt;/erlte-import&gt; &lt;erlte-import&gt;./fragments/head.html&lt;/erlte-import&gt; &lt;body&gt; &lt;!-- &lt;erlte-import&gt;./test/invalid/commented/import&lt;/erlte-import&gt; --&gt; &lt;!-- Test single line comment --&gt; &lt;!-- Test multiline comment --&gt; &lt;h1&gt;Hello world from {{erlte}}!&lt;/h1&gt; &lt;!-- Test comment with {{variable}} --&gt; &lt;erlte-import&gt;./fragments/footer.html&lt;/erlte-import&gt; &lt;/body&gt; &lt;erlte-import&gt;./fragments/html-end.html&lt;/erlte-import&gt; JavaScript import import &quot;./config&quot;; // You can import without .js file extension import &quot;./erlte&quot;; import &quot;./utils/base.js&quot;; // You can import with file extension import &quot;./utils/validator&quot;; // Let's call some functions erlte.S.Utils.Base.erlang(); erlte.S.Utils.Validator.isString(&quot;Erlang&quot;); CSS import @import &quot;test1.css&quot;; /* a { color: blue } */ /**/ /* */ div { /* inside */ color: green; /* between */ border-radius: 3px / 7px /* end */ }","ref":"readme.html#examples","title":"Overview - Examples","type":"extras"},{"doc":"How is compiling implemented? When ertle compiles the template, it produces a record containing one atom (holding original template file format) and one list (holding binaries and variables tuples). erlte also supports variables being used at the compilation stage. Good candidates are variables that rarely change. Not having to locate or replace them for each render may dramatically improve your rendering speed. Example of template and variables at compilation time: Template = &lt;&lt; &quot;{{constant}} {{anonfun}}! Mixing variables populated at compilation time with {{data}} at rendering time!&quot; &gt;&gt; , CompilationVariables = [ { constant , &quot;Hello&quot; } , %% Using your own function for rendering the variable is also possible { anonfun , { &quot;world&quot; , { f , module_name , function_name , undefined } } } ] , %% You can see erlte is smart enogh to merge the proper fragments toghether at compilation phase %% skipping only remaining variables! { ok , # erlte_compiled { format = txt , fragments = [ &lt;&lt; &quot;Hello world! Mixing variables populated at compilation time with &quot; &gt;&gt; , { v , &lt;&lt; &quot;data&quot; &gt;&gt; } , &lt;&lt; &quot; at rendering time!&quot; &gt;&gt; ] } } = erlte : compile ( { file , &quot;/path/to/template/file.html&quot; } , CompilationVariables ) . How is rendering implemented? ertle iterates your rendering variables once and replaces the variables in the compiled template list with the specified values. If the template contains variable names that are not specified at the rendering phase, the original variable names are kept untouched. All variable names that are not found in the template are simply ignored. At the end, you get an iolist of binaries. That's all folks!","ref":"readme.html#under-the-hood","title":"Overview - Under the hood","type":"extras"},{"doc":"Continuously fixing bugs and tuning performance. Writing more testing units. Keeping it simple and fast.","ref":"readme.html#project-roadmap","title":"Overview - Project roadmap","type":"extras"},{"doc":"erlte officially supports OTP release 20 and later. Development takes place using OTP 25 release and tests are done on: 25.0.3 24.3.4 23.3.4 22.3.4 21.3.8 20.3.8 Unofficially, you may be able to use erlte with older Erlang versions. No guarantee included.","ref":"readme.html#erlang-versions-supported","title":"Overview - Erlang versions supported","type":"extras"},{"doc":"None at this moment, but I intend to introduce erlhtml in the next version. erlhtml is Erlang library for URL encoding and escaping HTML entities mantained by the same author as erlte.","ref":"readme.html#dependencies","title":"Overview - Dependencies","type":"extras"},{"doc":"Madalin Grigore-Enescu (ergenius) github@ergenius.com","ref":"readme.html#authors","title":"Overview - Authors","type":"extras"},{"doc":"erlte is available under the MIT license (see LICENSE ).","ref":"readme.html#license","title":"Overview - License","type":"extras"},{"doc":"MIT License Copyright (c) 2022 Madalin Grigore-Enescu Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","ref":"license.html","title":"License","type":"extras"}]